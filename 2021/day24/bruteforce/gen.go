//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"

	"github.com/google/renameio"
)

func main() {
	prog, err := read(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}
	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, `// Code generated by gen.go. DO NOT EDIT.

package main

func eval(in []int) int {
	_ = in[13]
	var w, x, y, z int`)
	for _, l := range prog {
		fmt.Fprintln(buf, l)
	}
	fmt.Fprintln(buf, `return z
}`)
	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Println(err)
		out = buf.Bytes()
	}
	if err := renameio.WriteFile("prog.go", out, 0600); err != nil {
		log.Fatal(err)
	}
}

func read(r io.Reader) ([]string, error) {
	var (
		out []string
		inp int
	)
	s := bufio.NewScanner(r)
	for s.Scan() {
		f := strings.Fields(s.Text())
		switch f[0] {
		case "inp":
			out = append(out, fmt.Sprintf("%s = in[%d]", f[1], inp))
			inp++
		case "add":
			out = append(out, fmt.Sprintf("%s += %s", f[1], f[2]))
		case "mul":
			out = append(out, fmt.Sprintf("%s *= %s", f[1], f[2]))
		case "div":
			out = append(out, fmt.Sprintf("%s /= %s", f[1], f[2]))
		case "mod":
			out = append(out, fmt.Sprintf("%s %%= %s", f[1], f[2]))
		case "eql":
			out = append(out, fmt.Sprintf("if %s == %s { %s = 1 } else { %s = 0 }", f[1], f[2], f[1], f[1]))
		default:
			return nil, fmt.Errorf("unknown instruction %q", f[0])
		}
	}
	return out, s.Err()
}
